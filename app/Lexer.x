--This is an Alex file, it generates a lexer or lexical analyzer for JSON files
--It will generate a list of tokens that will then be consumed by the parser
--The file is split betwwen normal haskell code and alex syntax code

{
--here we define the exported data from Alex which we will use in the parser and main
module Lexer (
    Alex,
    alexMonadScan,
    runAlex,
    Token(..),
    AlexPosn(..),
    scanTokens,
    showPosn) where

import Control.Arrow ((&&&))
import Data.Char
import Data.Functor
import Numeric (readHex)
}

--This is the Alex syntax code, it defines the tokens and the actions to be taken when they are found

%wrapper "monadUserState" -- we used this wrapper for flexibility, we specified the user state to be a string to which we will add characters as we read them
%token "Token AlexPosn"   --tells Alex that each token generated by the lexer will be of type Token and will include position information provided by AlexPosn

--Regex expressions for digits, hex digits and Json numbers
$digit = 0-9
$hex = [0-9a-fA-F]

@number = \-?([1-9]$digit*|0)(\.$digit+)?([eE][\+\-]?$digit+)?

--here we define tokens for json: braces,brackets, colons, commas, bools, null, numbers and strings
tokens :-
  <0>       $white+         { skip                 }
  <0>       "{"             { symbol LBrace        }
  <0>       "}"             { symbol RBrace        }
  <0>       "["             { symbol LBracket      }
  <0>       "]"             { symbol RBracket      }
  <0>       ":"             { symbol Colon         }
  <0>       ","             { symbol Comma         }
  <0>       "true"          { mkBoolLit True       }
  <0>       "false"         { mkBoolLit False      }
  <0>       "null"          { mkNullLit            }
  <0>       @number         { digit                }
  <0>       \"              { begin string         }
  <string>  \\b             { appendChar '\b'      }
  <string>  \\f             { appendChar '\f'      }
  <string>  \\n             { appendChar '\n'      }
  <string>  \\r             { appendChar '\r'      }
  <string>  \\t             { appendChar '\t'      }
  <string>  \\\\            { appendChar '\\'      }
  <string>  \\ \/           { appendChar '/'       }
  <string>  \\ \"           { appendChar '"'       }
  <string>  \\u $hex{4}     { unicodeChar          }
  <string>  [^\"]           { strChar              }
  <string>  \"              { emitStr `andBegin` 0 }

{
-- this datatype defines the tokens that will be generated by the lexer in haskell
-- tokLoc allows us to keep track of the position of the token in the input file
-- tokStr, tokNum and tokBool are used to store the value of the token as haskell types
data Token a = LBrace    { tokLoc :: a }
             | RBrace    { tokLoc :: a }
             | LBracket  { tokLoc :: a }
             | RBracket  { tokLoc :: a }
             | Colon     { tokLoc :: a }
             | Comma     { tokLoc :: a }
             | StringLit { tokLoc :: a, tokStr :: String }
             | NumLit    { tokLoc :: a, tokNum :: Float }
             | BoolLit   { tokLoc :: a, tokBool :: Bool }
             | NullLit   { tokLoc :: a }
             | EOF       { tokLoc :: a }
             deriving (Eq)

-- encloses a string in double quotes
surround = ("\"" ++) . (++ "\"")

--define show typeclass for Tokens, useful for debugging and logging
instance Show (Token a) where
  show (LBrace _) = surround "{"
  show (RBrace _) = surround "}"
  show (LBracket _) = surround "["
  show (RBracket _) = surround "]"
  show (Colon _) = surround ":"
  show (Comma _) = surround ","
  show (StringLit _ s) = surround s
  show (NumLit _ n) = surround . show $ n
  show (BoolLit _ True) = "True"
  show (BoolLit _ False) = "False"
  show (NullLit _) = "null"
  show (EOF _) = "EOF"

--Formats the position information of a token.
showPosn (AlexPn _ l c) = show l ++ ":" ++ show c

--General helper to create a token with position and value.
mkL :: (AlexPosn -> String -> Token AlexPosn) -> AlexInput -> Int -> Alex (Token AlexPosn)
mkL tokfn (pos, _, _, input) len = return (tokfn pos $ take len input)


--Helper Functions to create bool and null literal tokens
mkBoolLit :: Bool -> AlexInput -> Int -> Alex (Token AlexPosn)
mkBoolLit b = mkL (\p _ -> BoolLit p b)

mkNullLit :: AlexInput -> Int -> Alex (Token AlexPosn)        -- Added helper for null
mkNullLit = mkL (\p _ -> NullLit p)

--Creates structural symbol tokens (e.g., {, }, [, ]).
symbol :: (AlexPosn -> Token AlexPosn) -> AlexInput -> Int -> Alex (Token AlexPosn)
symbol s = mkL (\p _ -> s p)

--Creates a numeric literal token.
digit :: AlexInput -> Int -> Alex (Token AlexPosn)
digit = mkL (\p s -> NumLit p $ read s)

--Adds a character to the accumulated string state.
addChar c = alexGetUserState >>= alexSetUserState . (c:) >> alexMonadScan

--Wrapper to append a character during string parsing.
appendChar c _ _ = addChar c

--Handles regular characters inside a string.
strChar (_, _, _, input) _ = addChar $ head input

--Handles Unicode escape sequences in strings.
unicodeChar (_, _, _, input) _ = case readHex $ drop 2 input of
  [(value, _)] -> addChar $ chr value
  _ -> alexError "invalid escape sequence"

--Emits a string literal token and resets the string accumulator.
emitStr :: AlexAction (Token AlexPosn)
emitStr (pos, _, _, _) _ = do
  strAcc <- alexGetUserState <&> reverse
  alexSetUserState ""
  return $ StringLit pos strAcc

--Retrieves the current position in the input.
get_pos :: Alex AlexPosn
get_pos = Alex (Right . (id &&& alex_pos))

--Creates an end-of-file token.
alexEOF = do
  pos <- get_pos
  return $ EOF pos

--define user state as string and initialize it as empty
type AlexUserState = String
alexInitUserState = ""

--Continuously scans and collects tokens until end-of-file.
loop = do
  tok' <- alexMonadScan
  case tok' of
    EOF _ -> return []
    t -> (t :) <$> loop

--Takes an input String (JSON text), runs the lexer (runAlex) with the loop function, and returns either an error message or a list of tokens with their positions.
scanTokens :: String -> Either String [Token AlexPosn]
scanTokens = flip runAlex loop
}
